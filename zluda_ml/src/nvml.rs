/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPciInfo_st {
    pub busIdLegacy: [::std::os::raw::c_char; 16usize],
    pub domain: ::std::os::raw::c_uint,
    pub bus: ::std::os::raw::c_uint,
    pub device: ::std::os::raw::c_uint,
    pub pciDeviceId: ::std::os::raw::c_uint,
    pub pciSubSystemId: ::std::os::raw::c_uint,
    pub busId: [::std::os::raw::c_char; 32usize],
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: ::std::os::raw::c_ulonglong,
    pub l2Cache: ::std::os::raw::c_ulonglong,
    pub deviceMemory: ::std::os::raw::c_ulonglong,
    pub registerFile: ::std::os::raw::c_ulonglong,
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUtilization_st {
    pub gpu: ::std::os::raw::c_uint,
    pub memory: ::std::os::raw::c_uint,
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlMemory_st {
    pub total: ::std::os::raw::c_ulonglong,
    pub free: ::std::os::raw::c_ulonglong,
    pub used: ::std::os::raw::c_ulonglong,
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: ::std::os::raw::c_ulonglong,
    pub bar1Free: ::std::os::raw::c_ulonglong,
    pub bar1Used: ::std::os::raw::c_ulonglong,
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlProcessInfo_st {
    pub pid: ::std::os::raw::c_uint,
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlDeviceAttributes_st {
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    pub sharedJpegCount: ::std::os::raw::c_uint,
    pub sharedOfaCount: ::std::os::raw::c_uint,
}
pub type nvmlDeviceAttributes_t = nvmlDeviceAttributes_st;
impl nvmlBridgeChipType_enum {
    pub const NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = nvmlBridgeChipType_enum(0);
}
impl nvmlBridgeChipType_enum {
    pub const NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = nvmlBridgeChipType_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlBridgeChipType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_CYCLES: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(0);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_PACKETS: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(1);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_BYTES: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(2);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_RESERVED: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(3);
}
impl nvmlNvLinkUtilizationCountUnits_enum {
    pub const NVML_NVLINK_COUNTER_UNIT_COUNT: nvmlNvLinkUtilizationCountUnits_enum =
        nvmlNvLinkUtilizationCountUnits_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkUtilizationCountUnits_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_NOP: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(1);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_READ: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(2);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_WRITE: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(4);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_RATOM: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(8);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_NRATOM: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(16);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_FLUSH: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(32);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(64);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(128);
}
impl nvmlNvLinkUtilizationCountPktTypes_enum {
    pub const NVML_NVLINK_COUNTER_PKTFILTER_ALL: nvmlNvLinkUtilizationCountPktTypes_enum =
        nvmlNvLinkUtilizationCountPktTypes_enum(255);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkUtilizationCountPktTypes_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum =
        nvmlNvLinkCapability_enum(0);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum =
        nvmlNvLinkCapability_enum(1);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(2);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum =
        nvmlNvLinkCapability_enum(3);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(4);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(5);
}
impl nvmlNvLinkCapability_enum {
    pub const NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = nvmlNvLinkCapability_enum(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkCapability_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(0);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(1);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(2);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
        nvmlNvLinkErrorCounter_enum(3);
}
impl nvmlNvLinkErrorCounter_enum {
    pub const NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = nvmlNvLinkErrorCounter_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlNvLinkErrorCounter_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = nvmlGpuLevel_enum(0);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(10);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(20);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(30);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = nvmlGpuLevel_enum(40);
}
impl nvmlGpuLevel_enum {
    pub const NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = nvmlGpuLevel_enum(50);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuLevel_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(0);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum =
        nvmlGpuP2PStatus_enum(1);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(2);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
        nvmlGpuP2PStatus_enum(3);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(4);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(5);
}
impl nvmlGpuP2PStatus_enum {
    pub const NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = nvmlGpuP2PStatus_enum(6);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuP2PStatus_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(0);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(1);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(2);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(3);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(4);
}
impl nvmlGpuP2PCapsIndex_enum {
    pub const NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = nvmlGpuP2PCapsIndex_enum(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuP2PCapsIndex_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: ::std::os::raw::c_uint,
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: ::std::os::raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
impl nvmlSamplingType_enum {
    pub const NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(0);
}
impl nvmlSamplingType_enum {
    pub const NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(1);
}
impl nvmlSamplingType_enum {
    pub const NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(2);
}
impl nvmlSamplingType_enum {
    pub const NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(3);
}
impl nvmlSamplingType_enum {
    pub const NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(4);
}
impl nvmlSamplingType_enum {
    pub const NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(5);
}
impl nvmlSamplingType_enum {
    pub const NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = nvmlSamplingType_enum(6);
}
impl nvmlSamplingType_enum {
    pub const NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = nvmlSamplingType_enum(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlSamplingType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
impl nvmlPcieUtilCounter_enum {
    pub const NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = nvmlPcieUtilCounter_enum(0);
}
impl nvmlPcieUtilCounter_enum {
    pub const NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = nvmlPcieUtilCounter_enum(1);
}
impl nvmlPcieUtilCounter_enum {
    pub const NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = nvmlPcieUtilCounter_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPcieUtilCounter_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = nvmlValueType_enum(0);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = nvmlValueType_enum(1);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = nvmlValueType_enum(2);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = nvmlValueType_enum(3);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = nvmlValueType_enum(4);
}
impl nvmlValueType_enum {
    pub const NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = nvmlValueType_enum(5);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlValueType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    pub dVal: f64,
    pub uiVal: ::std::os::raw::c_uint,
    pub ulVal: ::std::os::raw::c_ulong,
    pub ullVal: ::std::os::raw::c_ulonglong,
    pub sllVal: ::std::os::raw::c_longlong,
    _bindgen_union_align: u64,
}
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
pub type nvmlSample_t = nvmlSample_st;
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(0);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(1);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(2);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(3);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum =
        nvmlPerfPolicyType_enum(4);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(5);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum =
        nvmlPerfPolicyType_enum(10);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum =
        nvmlPerfPolicyType_enum(11);
}
impl nvmlPerfPolicyType_enum {
    pub const NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = nvmlPerfPolicyType_enum(12);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPerfPolicyType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlViolationTime_st {
    pub referenceTime: ::std::os::raw::c_ulonglong,
    pub violationTime: ::std::os::raw::c_ulonglong,
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
impl nvmlEnableState_enum {
    pub const NVML_FEATURE_DISABLED: nvmlEnableState_enum = nvmlEnableState_enum(0);
}
impl nvmlEnableState_enum {
    pub const NVML_FEATURE_ENABLED: nvmlEnableState_enum = nvmlEnableState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlEnableState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
impl nvmlBrandType_enum {
    pub const NVML_BRAND_UNKNOWN: nvmlBrandType_enum = nvmlBrandType_enum(0);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_QUADRO: nvmlBrandType_enum = nvmlBrandType_enum(1);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_TESLA: nvmlBrandType_enum = nvmlBrandType_enum(2);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_NVS: nvmlBrandType_enum = nvmlBrandType_enum(3);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_GRID: nvmlBrandType_enum = nvmlBrandType_enum(4);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_GEFORCE: nvmlBrandType_enum = nvmlBrandType_enum(5);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_TITAN: nvmlBrandType_enum = nvmlBrandType_enum(6);
}
impl nvmlBrandType_enum {
    pub const NVML_BRAND_COUNT: nvmlBrandType_enum = nvmlBrandType_enum(7);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlBrandType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_SHUTDOWN: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(0);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_SLOWDOWN: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(1);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_MEM_MAX: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(2);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_GPU_MAX: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(3);
}
impl nvmlTemperatureThresholds_enum {
    pub const NVML_TEMPERATURE_THRESHOLD_COUNT: nvmlTemperatureThresholds_enum =
        nvmlTemperatureThresholds_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlTemperatureThresholds_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
impl nvmlTemperatureSensors_enum {
    pub const NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = nvmlTemperatureSensors_enum(0);
}
impl nvmlTemperatureSensors_enum {
    pub const NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = nvmlTemperatureSensors_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlTemperatureSensors_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = nvmlComputeMode_enum(0);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = nvmlComputeMode_enum(1);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = nvmlComputeMode_enum(2);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = nvmlComputeMode_enum(3);
}
impl nvmlComputeMode_enum {
    pub const NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = nvmlComputeMode_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlComputeMode_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
impl nvmlMemoryErrorType_enum {
    pub const NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum =
        nvmlMemoryErrorType_enum(0);
}
impl nvmlMemoryErrorType_enum {
    pub const NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum =
        nvmlMemoryErrorType_enum(1);
}
impl nvmlMemoryErrorType_enum {
    pub const NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = nvmlMemoryErrorType_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlMemoryErrorType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
impl nvmlEccCounterType_enum {
    pub const NVML_VOLATILE_ECC: nvmlEccCounterType_enum = nvmlEccCounterType_enum(0);
}
impl nvmlEccCounterType_enum {
    pub const NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = nvmlEccCounterType_enum(1);
}
impl nvmlEccCounterType_enum {
    pub const NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = nvmlEccCounterType_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlEccCounterType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
impl nvmlClockType_enum {
    pub const NVML_CLOCK_GRAPHICS: nvmlClockType_enum = nvmlClockType_enum(0);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_SM: nvmlClockType_enum = nvmlClockType_enum(1);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_MEM: nvmlClockType_enum = nvmlClockType_enum(2);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_VIDEO: nvmlClockType_enum = nvmlClockType_enum(3);
}
impl nvmlClockType_enum {
    pub const NVML_CLOCK_COUNT: nvmlClockType_enum = nvmlClockType_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlClockType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlClockType_enum as nvmlClockType_t;
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = nvmlClockId_enum(0);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = nvmlClockId_enum(1);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = nvmlClockId_enum(2);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = nvmlClockId_enum(3);
}
impl nvmlClockId_enum {
    pub const NVML_CLOCK_ID_COUNT: nvmlClockId_enum = nvmlClockId_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlClockId_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlClockId_enum as nvmlClockId_t;
impl nvmlDriverModel_enum {
    pub const NVML_DRIVER_WDDM: nvmlDriverModel_enum = nvmlDriverModel_enum(0);
}
impl nvmlDriverModel_enum {
    pub const NVML_DRIVER_WDM: nvmlDriverModel_enum = nvmlDriverModel_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlDriverModel_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
impl nvmlPStates_enum {
    pub const NVML_PSTATE_0: nvmlPStates_enum = nvmlPStates_enum(0);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_1: nvmlPStates_enum = nvmlPStates_enum(1);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_2: nvmlPStates_enum = nvmlPStates_enum(2);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_3: nvmlPStates_enum = nvmlPStates_enum(3);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_4: nvmlPStates_enum = nvmlPStates_enum(4);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_5: nvmlPStates_enum = nvmlPStates_enum(5);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_6: nvmlPStates_enum = nvmlPStates_enum(6);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_7: nvmlPStates_enum = nvmlPStates_enum(7);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_8: nvmlPStates_enum = nvmlPStates_enum(8);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_9: nvmlPStates_enum = nvmlPStates_enum(9);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_10: nvmlPStates_enum = nvmlPStates_enum(10);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_11: nvmlPStates_enum = nvmlPStates_enum(11);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_12: nvmlPStates_enum = nvmlPStates_enum(12);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_13: nvmlPStates_enum = nvmlPStates_enum(13);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_14: nvmlPStates_enum = nvmlPStates_enum(14);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_15: nvmlPStates_enum = nvmlPStates_enum(15);
}
impl nvmlPStates_enum {
    pub const NVML_PSTATE_UNKNOWN: nvmlPStates_enum = nvmlPStates_enum(32);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPStates_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPStates_enum as nvmlPstates_t;
impl nvmlGom_enum {
    pub const NVML_GOM_ALL_ON: nvmlGom_enum = nvmlGom_enum(0);
}
impl nvmlGom_enum {
    pub const NVML_GOM_COMPUTE: nvmlGom_enum = nvmlGom_enum(1);
}
impl nvmlGom_enum {
    pub const NVML_GOM_LOW_DP: nvmlGom_enum = nvmlGom_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGom_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_OEM: nvmlInforomObject_enum = nvmlInforomObject_enum(0);
}
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_ECC: nvmlInforomObject_enum = nvmlInforomObject_enum(1);
}
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_POWER: nvmlInforomObject_enum = nvmlInforomObject_enum(2);
}
impl nvmlInforomObject_enum {
    pub const NVML_INFOROM_COUNT: nvmlInforomObject_enum = nvmlInforomObject_enum(3);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlInforomObject_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
impl nvmlReturn_enum {
    pub const NVML_SUCCESS: nvmlReturn_enum = nvmlReturn_enum(0);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = nvmlReturn_enum(1);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = nvmlReturn_enum(2);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = nvmlReturn_enum(3);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = nvmlReturn_enum(4);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = nvmlReturn_enum(5);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NOT_FOUND: nvmlReturn_enum = nvmlReturn_enum(6);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = nvmlReturn_enum(7);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = nvmlReturn_enum(8);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = nvmlReturn_enum(9);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_TIMEOUT: nvmlReturn_enum = nvmlReturn_enum(10);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = nvmlReturn_enum(11);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = nvmlReturn_enum(12);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = nvmlReturn_enum(13);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = nvmlReturn_enum(14);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = nvmlReturn_enum(15);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = nvmlReturn_enum(16);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = nvmlReturn_enum(17);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = nvmlReturn_enum(18);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_IN_USE: nvmlReturn_enum = nvmlReturn_enum(19);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_MEMORY: nvmlReturn_enum = nvmlReturn_enum(20);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_NO_DATA: nvmlReturn_enum = nvmlReturn_enum(21);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = nvmlReturn_enum(22);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_INSUFFICIENT_RESOURCES: nvmlReturn_enum = nvmlReturn_enum(23);
}
impl nvmlReturn_enum {
    pub const NVML_ERROR_UNKNOWN: nvmlReturn_enum = nvmlReturn_enum(999);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlReturn_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlReturn_enum as nvmlReturn_t;
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(0);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(1);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(2);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(2);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(3);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(4);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum =
        nvmlMemoryLocation_enum(5);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(6);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(7);
}
impl nvmlMemoryLocation_enum {
    pub const NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = nvmlMemoryLocation_enum(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlMemoryLocation_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
impl nvmlPageRetirementCause_enum {
    pub const NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
        nvmlPageRetirementCause_enum = nvmlPageRetirementCause_enum(0);
}
impl nvmlPageRetirementCause_enum {
    pub const NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR: nvmlPageRetirementCause_enum =
        nvmlPageRetirementCause_enum(1);
}
impl nvmlPageRetirementCause_enum {
    pub const NVML_PAGE_RETIREMENT_CAUSE_COUNT: nvmlPageRetirementCause_enum =
        nvmlPageRetirementCause_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPageRetirementCause_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
impl nvmlRestrictedAPI_enum {
    pub const NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS: nvmlRestrictedAPI_enum =
        nvmlRestrictedAPI_enum(0);
}
impl nvmlRestrictedAPI_enum {
    pub const NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS: nvmlRestrictedAPI_enum =
        nvmlRestrictedAPI_enum(1);
}
impl nvmlRestrictedAPI_enum {
    pub const NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = nvmlRestrictedAPI_enum(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlRestrictedAPI_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(0);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(1);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(2);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(3);
}
impl nvmlGpuVirtualizationMode {
    pub const NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA: nvmlGpuVirtualizationMode =
        nvmlGpuVirtualizationMode(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGpuVirtualizationMode(pub ::std::os::raw::c_uint);
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
impl nvmlHostVgpuMode_enum {
    pub const NVML_HOST_VGPU_MODE_NON_SRIOV: nvmlHostVgpuMode_enum = nvmlHostVgpuMode_enum(0);
}
impl nvmlHostVgpuMode_enum {
    pub const NVML_HOST_VGPU_MODE_SRIOV: nvmlHostVgpuMode_enum = nvmlHostVgpuMode_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlHostVgpuMode_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlHostVgpuMode_enum as nvmlHostVgpuMode_t;
impl nvmlVgpuVmIdType {
    pub const NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = nvmlVgpuVmIdType(0);
}
impl nvmlVgpuVmIdType {
    pub const NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = nvmlVgpuVmIdType(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuVmIdType(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
impl nvmlVgpuGuestInfoState_enum {
    pub const NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED: nvmlVgpuGuestInfoState_enum =
        nvmlVgpuGuestInfoState_enum(0);
}
impl nvmlVgpuGuestInfoState_enum {
    pub const NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED: nvmlVgpuGuestInfoState_enum =
        nvmlVgpuGuestInfoState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuGuestInfoState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_VGPU: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(1);
}
impl nvmlGridLicenseFeatureCode_t {
    pub const NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION: nvmlGridLicenseFeatureCode_t =
        nvmlGridLicenseFeatureCode_t(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlGridLicenseFeatureCode_t(pub ::std::os::raw::c_uint);
pub type nvmlVgpuTypeId_t = ::std::os::raw::c_uint;
pub type nvmlVgpuInstance_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub smUtil: nvmlValue_t,
    pub memUtil: nvmlValue_t,
    pub encUtil: nvmlValue_t,
    pub decUtil: nvmlValue_t,
}
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub pid: ::std::os::raw::c_uint,
    pub processName: [::std::os::raw::c_char; 64usize],
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub smUtil: ::std::os::raw::c_uint,
    pub memUtil: ::std::os::raw::c_uint,
    pub encUtil: ::std::os::raw::c_uint,
    pub decUtil: ::std::os::raw::c_uint,
}
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlProcessUtilizationSample_st {
    pub pid: ::std::os::raw::c_uint,
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub smUtil: ::std::os::raw::c_uint,
    pub memUtil: ::std::os::raw::c_uint,
    pub encUtil: ::std::os::raw::c_uint,
    pub decUtil: ::std::os::raw::c_uint,
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeature_st {
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    pub featureState: ::std::os::raw::c_uint,
    pub licenseInfo: [::std::os::raw::c_char; 128usize],
    pub productName: [::std::os::raw::c_char; 128usize],
    pub featureEnabled: ::std::os::raw::c_uint,
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeatures_st {
    pub isGridLicenseSupported: ::std::os::raw::c_int,
    pub licensableFeaturesCount: ::std::os::raw::c_uint,
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub type nvmlDeviceArchitecture_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    pub fieldId: ::std::os::raw::c_uint,
    pub scopeId: ::std::os::raw::c_uint,
    pub timestamp: ::std::os::raw::c_longlong,
    pub latencyUsec: ::std::os::raw::c_longlong,
    pub valueType: nvmlValueType_t,
    pub nvmlReturn: nvmlReturn_t,
    pub value: nvmlValue_t,
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: ::std::os::raw::c_uint,
    pub firmwareVersion: [::std::os::raw::c_char; 32usize],
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
impl nvmlFanState_enum {
    pub const NVML_FAN_NORMAL: nvmlFanState_enum = nvmlFanState_enum(0);
}
impl nvmlFanState_enum {
    pub const NVML_FAN_FAILED: nvmlFanState_enum = nvmlFanState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlFanState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlFanState_enum as nvmlFanState_t;
impl nvmlLedColor_enum {
    pub const NVML_LED_COLOR_GREEN: nvmlLedColor_enum = nvmlLedColor_enum(0);
}
impl nvmlLedColor_enum {
    pub const NVML_LED_COLOR_AMBER: nvmlLedColor_enum = nvmlLedColor_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlLedColor_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlLedState_st {
    pub cause: [::std::os::raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitInfo_st {
    pub name: [::std::os::raw::c_char; 96usize],
    pub id: [::std::os::raw::c_char; 96usize],
    pub serial: [::std::os::raw::c_char; 96usize],
    pub firmwareVersion: [::std::os::raw::c_char; 96usize],
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPSUInfo_st {
    pub state: [::std::os::raw::c_char; 256usize],
    pub current: ::std::os::raw::c_uint,
    pub voltage: ::std::os::raw::c_uint,
    pub power: ::std::os::raw::c_uint,
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitFanInfo_st {
    pub speed: ::std::os::raw::c_uint,
    pub state: nvmlFanState_t,
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: ::std::os::raw::c_uint,
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: ::std::os::raw::c_ulonglong,
    pub eventData: ::std::os::raw::c_ulonglong,
    pub gpuInstanceId: ::std::os::raw::c_uint,
    pub computeInstanceId: ::std::os::raw::c_uint,
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: ::std::os::raw::c_uint,
    pub memoryUtilization: ::std::os::raw::c_uint,
    pub maxMemoryUsage: ::std::os::raw::c_ulonglong,
    pub time: ::std::os::raw::c_ulonglong,
    pub startTime: ::std::os::raw::c_ulonglong,
    pub isRunning: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 5usize],
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
impl nvmlEncoderQueryType_enum {
    pub const NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = nvmlEncoderQueryType_enum(0);
}
impl nvmlEncoderQueryType_enum {
    pub const NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = nvmlEncoderQueryType_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlEncoderQueryType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlEncoderSessionInfo_st {
    pub sessionId: ::std::os::raw::c_uint,
    pub pid: ::std::os::raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub codecType: nvmlEncoderType_t,
    pub hResolution: ::std::os::raw::c_uint,
    pub vResolution: ::std::os::raw::c_uint,
    pub averageFps: ::std::os::raw::c_uint,
    pub averageLatency: ::std::os::raw::c_uint,
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(0);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(1);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(2);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(3);
}
impl nvmlFBCSessionType_enum {
    pub const NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = nvmlFBCSessionType_enum(4);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlFBCSessionType_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFBCStats_st {
    pub sessionsCount: ::std::os::raw::c_uint,
    pub averageFPS: ::std::os::raw::c_uint,
    pub averageLatency: ::std::os::raw::c_uint,
}
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFBCSessionInfo_st {
    pub sessionId: ::std::os::raw::c_uint,
    pub pid: ::std::os::raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub displayOrdinal: ::std::os::raw::c_uint,
    pub sessionType: nvmlFBCSessionType_t,
    pub sessionFlags: ::std::os::raw::c_uint,
    pub hMaxResolution: ::std::os::raw::c_uint,
    pub vMaxResolution: ::std::os::raw::c_uint,
    pub hResolution: ::std::os::raw::c_uint,
    pub vResolution: ::std::os::raw::c_uint,
    pub averageFPS: ::std::os::raw::c_uint,
    pub averageLatency: ::std::os::raw::c_uint,
}
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
impl nvmlDetachGpuState_enum {
    pub const NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = nvmlDetachGpuState_enum(0);
}
impl nvmlDetachGpuState_enum {
    pub const NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = nvmlDetachGpuState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlDetachGpuState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
impl nvmlPcieLinkState_enum {
    pub const NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = nvmlPcieLinkState_enum(0);
}
impl nvmlPcieLinkState_enum {
    pub const NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = nvmlPcieLinkState_enum(1);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlPcieLinkState_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;

#[no_mangle]
pub extern "C" fn nvmlInit_v2() -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlInit() -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlInitWithFlags(flags: ::std::os::raw::c_uint) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlShutdown() -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlErrorString(result: nvmlReturn_t) -> *const ::std::os::raw::c_char {
    c"".as_ptr()
}

#[no_mangle]
pub unsafe extern "C" fn nvmlSystemGetDriverVersion(
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetNVMLVersion(
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetCudaDriverVersion(
    cudaDriverVersion: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetCudaDriverVersion_v2(
    cudaDriverVersion: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetProcessName(
    pid: ::std::os::raw::c_uint,
    name: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetCount(unitCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetHandleByIndex(
    index: ::std::os::raw::c_uint,
    unit: *mut nvmlUnit_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetLedState(
    unit: nvmlUnit_t,
    state: *mut nvmlLedState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetTemperature(
    unit: nvmlUnit_t,
    type_: ::std::os::raw::c_uint,
    temp: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetFanSpeedInfo(
    unit: nvmlUnit_t,
    fanSpeeds: *mut nvmlUnitFanSpeeds_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitGetDevices(
    unit: nvmlUnit_t,
    deviceCount: *mut ::std::os::raw::c_uint,
    devices: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetHicVersion(
    hwbcCount: *mut ::std::os::raw::c_uint,
    hwbcEntries: *mut nvmlHwbcEntry_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCount_v2(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAttributes(
    device: nvmlDevice_t,
    attributes: *mut nvmlDeviceAttributes_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByIndex_v2(
    index: ::std::os::raw::c_uint,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleBySerial(
    serial: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByUUID(
    uuid: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHandleByPciBusId_v2(
    pciBusId: *const ::std::os::raw::c_char,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetName(
    device: nvmlDevice_t,
    name: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBrand(
    device: nvmlDevice_t,
    type_: *mut nvmlBrandType_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetIndex(
    device: nvmlDevice_t,
    index: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSerial(
    device: nvmlDevice_t,
    serial: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}
pub type nvmlAffinityScope_t = ::std::os::raw::c_uint;

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryAffinity(
    device: nvmlDevice_t,
    nodeSetSize: ::std::os::raw::c_uint,
    nodeSet: *mut ::std::os::raw::c_ulong,
    scope: nvmlAffinityScope_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCpuAffinityWithinScope(
    device: nvmlDevice_t,
    cpuSetSize: ::std::os::raw::c_uint,
    cpuSet: *mut ::std::os::raw::c_ulong,
    scope: nvmlAffinityScope_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCpuAffinity(
    device: nvmlDevice_t,
    cpuSetSize: ::std::os::raw::c_uint,
    cpuSet: *mut ::std::os::raw::c_ulong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTopologyCommonAncestor(
    device1: nvmlDevice_t,
    device2: nvmlDevice_t,
    pathInfo: *mut nvmlGpuTopologyLevel_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTopologyNearestGpus(
    device: nvmlDevice_t,
    level: nvmlGpuTopologyLevel_t,
    count: *mut ::std::os::raw::c_uint,
    deviceArray: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSystemGetTopologyGpuSet(
    cpuNumber: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
    deviceArray: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetP2PStatus(
    device1: nvmlDevice_t,
    device2: nvmlDevice_t,
    p2pIndex: nvmlGpuP2PCapsIndex_t,
    p2pStatus: *mut nvmlGpuP2PStatus_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetUUID(
    device: nvmlDevice_t,
    uuid: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetMdevUUID(
    vgpuInstance: nvmlVgpuInstance_t,
    mdevUuid: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMinorNumber(
    device: nvmlDevice_t,
    minorNumber: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBoardPartNumber(
    device: nvmlDevice_t,
    partNumber: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetInforomVersion(
    device: nvmlDevice_t,
    object: nvmlInforomObject_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetInforomImageVersion(
    device: nvmlDevice_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetInforomConfigurationChecksum(
    device: nvmlDevice_t,
    checksum: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDisplayMode(
    device: nvmlDevice_t,
    display: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDisplayActive(
    device: nvmlDevice_t,
    isActive: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPersistenceMode(
    device: nvmlDevice_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPciInfo_v3(
    device: nvmlDevice_t,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxPcieLinkGeneration(
    device: nvmlDevice_t,
    maxLinkGen: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxPcieLinkWidth(
    device: nvmlDevice_t,
    maxLinkWidth: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrPcieLinkGeneration(
    device: nvmlDevice_t,
    currLinkGen: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrPcieLinkWidth(
    device: nvmlDevice_t,
    currLinkWidth: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPcieThroughput(
    device: nvmlDevice_t,
    counter: nvmlPcieUtilCounter_t,
    value: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPcieReplayCounter(
    device: nvmlDevice_t,
    value: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetClockInfo(
    device: nvmlDevice_t,
    type_: nvmlClockType_t,
    clock: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxClockInfo(
    device: nvmlDevice_t,
    type_: nvmlClockType_t,
    clock: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetApplicationsClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDefaultApplicationsClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockId: nvmlClockId_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxCustomerBoostClock(
    device: nvmlDevice_t,
    clockType: nvmlClockType_t,
    clockMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedMemoryClocks(
    device: nvmlDevice_t,
    count: *mut ::std::os::raw::c_uint,
    clocksMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedGraphicsClocks(
    device: nvmlDevice_t,
    memoryClockMHz: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
    clocksMHz: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAutoBoostedClocksEnabled(
    device: nvmlDevice_t,
    isEnabled: *mut nvmlEnableState_t,
    defaultIsEnabled: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetAutoBoostedClocksEnabled(
    device: nvmlDevice_t,
    enabled: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
    device: nvmlDevice_t,
    enabled: nvmlEnableState_t,
    flags: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFanSpeed(
    device: nvmlDevice_t,
    speed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFanSpeed_v2(
    device: nvmlDevice_t,
    fan: ::std::os::raw::c_uint,
    speed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTemperature(
    device: nvmlDevice_t,
    sensorType: nvmlTemperatureSensors_t,
    temp: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTemperatureThreshold(
    device: nvmlDevice_t,
    thresholdType: nvmlTemperatureThresholds_t,
    temp: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPerformanceState(
    device: nvmlDevice_t,
    pState: *mut nvmlPstates_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCurrentClocksThrottleReasons(
    device: nvmlDevice_t,
    clocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedClocksThrottleReasons(
    device: nvmlDevice_t,
    supportedClocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerState(
    device: nvmlDevice_t,
    pState: *mut nvmlPstates_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementMode(
    device: nvmlDevice_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementLimit(
    device: nvmlDevice_t,
    limit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementLimitConstraints(
    device: nvmlDevice_t,
    minLimit: *mut ::std::os::raw::c_uint,
    maxLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerManagementDefaultLimit(
    device: nvmlDevice_t,
    defaultLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPowerUsage(
    device: nvmlDevice_t,
    power: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTotalEnergyConsumption(
    device: nvmlDevice_t,
    energy: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEnforcedPowerLimit(
    device: nvmlDevice_t,
    limit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuOperationMode(
    device: nvmlDevice_t,
    current: *mut nvmlGpuOperationMode_t,
    pending: *mut nvmlGpuOperationMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryInfo(
    device: nvmlDevice_t,
    memory: *mut nvmlMemory_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeMode(
    device: nvmlDevice_t,
    mode: *mut nvmlComputeMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCudaComputeCapability(
    device: nvmlDevice_t,
    major: *mut ::std::os::raw::c_int,
    minor: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEccMode(
    device: nvmlDevice_t,
    current: *mut nvmlEnableState_t,
    pending: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBoardId(
    device: nvmlDevice_t,
    boardId: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMultiGpuBoard(
    device: nvmlDevice_t,
    multiGpuBool: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetTotalEccErrors(
    device: nvmlDevice_t,
    errorType: nvmlMemoryErrorType_t,
    counterType: nvmlEccCounterType_t,
    eccCounts: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDetailedEccErrors(
    device: nvmlDevice_t,
    errorType: nvmlMemoryErrorType_t,
    counterType: nvmlEccCounterType_t,
    eccCounts: *mut nvmlEccErrorCounts_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMemoryErrorCounter(
    device: nvmlDevice_t,
    errorType: nvmlMemoryErrorType_t,
    counterType: nvmlEccCounterType_t,
    locationType: nvmlMemoryLocation_t,
    count: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetUtilizationRates(
    device: nvmlDevice_t,
    utilization: *mut nvmlUtilization_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderUtilization(
    device: nvmlDevice_t,
    utilization: *mut ::std::os::raw::c_uint,
    samplingPeriodUs: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderCapacity(
    device: nvmlDevice_t,
    encoderQueryType: nvmlEncoderType_t,
    encoderCapacity: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderStats(
    device: nvmlDevice_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    averageFps: *mut ::std::os::raw::c_uint,
    averageLatency: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetEncoderSessions(
    device: nvmlDevice_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfos: *mut nvmlEncoderSessionInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDecoderUtilization(
    device: nvmlDevice_t,
    utilization: *mut ::std::os::raw::c_uint,
    samplingPeriodUs: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFBCStats(
    device: nvmlDevice_t,
    fbcStats: *mut nvmlFBCStats_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFBCSessions(
    device: nvmlDevice_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfo: *mut nvmlFBCSessionInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDriverModel(
    device: nvmlDevice_t,
    current: *mut nvmlDriverModel_t,
    pending: *mut nvmlDriverModel_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVbiosVersion(
    device: nvmlDevice_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBridgeChipInfo(
    device: nvmlDevice_t,
    bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeRunningProcesses(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGraphicsRunningProcesses(
    device: nvmlDevice_t,
    infoCount: *mut ::std::os::raw::c_uint,
    infos: *mut nvmlProcessInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceOnSameBoard(
    device1: nvmlDevice_t,
    device2: nvmlDevice_t,
    onSameBoard: *mut ::std::os::raw::c_int,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAPIRestriction(
    device: nvmlDevice_t,
    apiType: nvmlRestrictedAPI_t,
    isRestricted: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSamples(
    device: nvmlDevice_t,
    type_: nvmlSamplingType_t,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    sampleValType: *mut nvmlValueType_t,
    sampleCount: *mut ::std::os::raw::c_uint,
    samples: *mut nvmlSample_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetBAR1MemoryInfo(
    device: nvmlDevice_t,
    bar1Memory: *mut nvmlBAR1Memory_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetViolationStatus(
    device: nvmlDevice_t,
    perfPolicyType: nvmlPerfPolicyType_t,
    violTime: *mut nvmlViolationTime_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingMode(
    device: nvmlDevice_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingStats(
    device: nvmlDevice_t,
    pid: ::std::os::raw::c_uint,
    stats: *mut nvmlAccountingStats_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingPids(
    device: nvmlDevice_t,
    count: *mut ::std::os::raw::c_uint,
    pids: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetAccountingBufferSize(
    device: nvmlDevice_t,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRetiredPages(
    device: nvmlDevice_t,
    cause: nvmlPageRetirementCause_t,
    pageCount: *mut ::std::os::raw::c_uint,
    addresses: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRetiredPages_v2(
    device: nvmlDevice_t,
    cause: nvmlPageRetirementCause_t,
    pageCount: *mut ::std::os::raw::c_uint,
    addresses: *mut ::std::os::raw::c_ulonglong,
    timestamps: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRetiredPagesPendingStatus(
    device: nvmlDevice_t,
    isPending: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetRemappedRows(
    device: nvmlDevice_t,
    corrRows: *mut ::std::os::raw::c_uint,
    uncRows: *mut ::std::os::raw::c_uint,
    isPending: *mut ::std::os::raw::c_uint,
    failureOccurred: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetArchitecture(
    device: nvmlDevice_t,
    arch: *mut nvmlDeviceArchitecture_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetPersistenceMode(
    device: nvmlDevice_t,
    mode: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetComputeMode(
    device: nvmlDevice_t,
    mode: nvmlComputeMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetEccMode(
    device: nvmlDevice_t,
    ecc: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearEccErrorCounts(
    device: nvmlDevice_t,
    counterType: nvmlEccCounterType_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetDriverModel(
    device: nvmlDevice_t,
    driverModel: nvmlDriverModel_t,
    flags: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetGpuLockedClocks(
    device: nvmlDevice_t,
    minGpuClockMHz: ::std::os::raw::c_uint,
    maxGpuClockMHz: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetGpuLockedClocks(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetApplicationsClocks(
    device: nvmlDevice_t,
    memClockMHz: ::std::os::raw::c_uint,
    graphicsClockMHz: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetPowerManagementLimit(
    device: nvmlDevice_t,
    limit: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetGpuOperationMode(
    device: nvmlDevice_t,
    mode: nvmlGpuOperationMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetAPIRestriction(
    device: nvmlDevice_t,
    apiType: nvmlRestrictedAPI_t,
    isRestricted: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetAccountingMode(
    device: nvmlDevice_t,
    mode: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkState(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    isActive: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkVersion(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    version: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkCapability(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    capability: nvmlNvLinkCapability_t,
    capResult: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    pci: *mut nvmlPciInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkErrorCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: nvmlNvLinkErrorCounter_t,
    counterValue: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetNvLinkErrorCounters(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetNvLinkUtilizationControl(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    control: *mut nvmlNvLinkUtilizationControl_t,
    reset: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkUtilizationControl(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    control: *mut nvmlNvLinkUtilizationControl_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetNvLinkUtilizationCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    rxcounter: *mut ::std::os::raw::c_ulonglong,
    txcounter: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceFreezeNvLinkUtilizationCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
    freeze: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceResetNvLinkUtilizationCounter(
    device: nvmlDevice_t,
    link: ::std::os::raw::c_uint,
    counter: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceRegisterEvents(
    device: nvmlDevice_t,
    eventTypes: ::std::os::raw::c_ulonglong,
    set: nvmlEventSet_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedEventTypes(
    device: nvmlDevice_t,
    eventTypes: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetWait_v2(
    set: nvmlEventSet_t,
    data: *mut nvmlEventData_t,
    timeoutms: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceModifyDrainState(
    pciInfo: *mut nvmlPciInfo_t,
    newState: nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceQueryDrainState(
    pciInfo: *mut nvmlPciInfo_t,
    currentState: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceRemoveGpu_v2(
    pciInfo: *mut nvmlPciInfo_t,
    gpuState: nvmlDetachGpuState_t,
    linkState: nvmlPcieLinkState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetFieldValues(
    device: nvmlDevice_t,
    valuesCount: ::std::os::raw::c_int,
    values: *mut nvmlFieldValue_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVirtualizationMode(
    device: nvmlDevice_t,
    pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetHostVgpuMode(
    device: nvmlDevice_t,
    pHostVgpuMode: *mut nvmlHostVgpuMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceSetVirtualizationMode(
    device: nvmlDevice_t,
    virtualMode: nvmlGpuVirtualizationMode_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGridLicensableFeatures_v3(
    device: nvmlDevice_t,
    pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetProcessUtilization(
    device: nvmlDevice_t,
    utilization: *mut nvmlProcessUtilizationSample_t,
    processSamplesCount: *mut ::std::os::raw::c_uint,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetSupportedVgpus(
    device: nvmlDevice_t,
    vgpuCount: *mut ::std::os::raw::c_uint,
    vgpuTypeIds: *mut nvmlVgpuTypeId_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetCreatableVgpus(
    device: nvmlDevice_t,
    vgpuCount: *mut ::std::os::raw::c_uint,
    vgpuTypeIds: *mut nvmlVgpuTypeId_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetClass(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuTypeClass: *mut ::std::os::raw::c_char,
    size: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetName(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuTypeName: *mut ::std::os::raw::c_char,
    size: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetDeviceID(
    vgpuTypeId: nvmlVgpuTypeId_t,
    deviceID: *mut ::std::os::raw::c_ulonglong,
    subsystemID: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetFramebufferSize(
    vgpuTypeId: nvmlVgpuTypeId_t,
    fbSize: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetNumDisplayHeads(
    vgpuTypeId: nvmlVgpuTypeId_t,
    numDisplayHeads: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetResolution(
    vgpuTypeId: nvmlVgpuTypeId_t,
    displayIndex: ::std::os::raw::c_uint,
    xdim: *mut ::std::os::raw::c_uint,
    ydim: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetLicense(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuTypeLicenseString: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetFrameRateLimit(
    vgpuTypeId: nvmlVgpuTypeId_t,
    frameRateLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetMaxInstances(
    device: nvmlDevice_t,
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuInstanceCount: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuTypeGetMaxInstancesPerVm(
    vgpuTypeId: nvmlVgpuTypeId_t,
    vgpuInstanceCountPerVm: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetActiveVgpus(
    device: nvmlDevice_t,
    vgpuCount: *mut ::std::os::raw::c_uint,
    vgpuInstances: *mut nvmlVgpuInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetVmID(
    vgpuInstance: nvmlVgpuInstance_t,
    vmId: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
    vmIdType: *mut nvmlVgpuVmIdType_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetUUID(
    vgpuInstance: nvmlVgpuInstance_t,
    uuid: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetVmDriverVersion(
    vgpuInstance: nvmlVgpuInstance_t,
    version: *mut ::std::os::raw::c_char,
    length: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFbUsage(
    vgpuInstance: nvmlVgpuInstance_t,
    fbUsage: *mut ::std::os::raw::c_ulonglong,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetLicenseStatus(
    vgpuInstance: nvmlVgpuInstance_t,
    licensed: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetType(
    vgpuInstance: nvmlVgpuInstance_t,
    vgpuTypeId: *mut nvmlVgpuTypeId_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFrameRateLimit(
    vgpuInstance: nvmlVgpuInstance_t,
    frameRateLimit: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEccMode(
    vgpuInstance: nvmlVgpuInstance_t,
    eccMode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEncoderCapacity(
    vgpuInstance: nvmlVgpuInstance_t,
    encoderCapacity: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceSetEncoderCapacity(
    vgpuInstance: nvmlVgpuInstance_t,
    encoderCapacity: ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEncoderStats(
    vgpuInstance: nvmlVgpuInstance_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    averageFps: *mut ::std::os::raw::c_uint,
    averageLatency: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetEncoderSessions(
    vgpuInstance: nvmlVgpuInstance_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfo: *mut nvmlEncoderSessionInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFBCStats(
    vgpuInstance: nvmlVgpuInstance_t,
    fbcStats: *mut nvmlFBCStats_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetFBCSessions(
    vgpuInstance: nvmlVgpuInstance_t,
    sessionCount: *mut ::std::os::raw::c_uint,
    sessionInfo: *mut nvmlFBCSessionInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuVersion_st {
    pub minVersion: ::std::os::raw::c_uint,
    pub maxVersion: ::std::os::raw::c_uint,
}
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuMetadata_st {
    pub version: ::std::os::raw::c_uint,
    pub revision: ::std::os::raw::c_uint,
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    pub guestDriverVersion: [::std::os::raw::c_char; 80usize],
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    pub reserved: [::std::os::raw::c_uint; 6usize],
    pub vgpuVirtualizationCaps: ::std::os::raw::c_uint,
    pub guestVgpuVersion: ::std::os::raw::c_uint,
    pub opaqueDataSize: ::std::os::raw::c_uint,
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuMetadata_st {
    pub version: ::std::os::raw::c_uint,
    pub revision: ::std::os::raw::c_uint,
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    pub pgpuVirtualizationCaps: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 5usize],
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    pub opaqueDataSize: ::std::os::raw::c_uint,
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_NONE: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(0);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_COLD: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(1);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_HIBERNATE: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(2);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_SLEEP: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(4);
}
impl nvmlVgpuVmCompatibility_enum {
    pub const NVML_VGPU_VM_COMPATIBILITY_LIVE: nvmlVgpuVmCompatibility_enum =
        nvmlVgpuVmCompatibility_enum(8);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuVmCompatibility_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_NONE: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(0);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(1);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(2);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_GPU: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(4);
}
impl nvmlVgpuPgpuCompatibilityLimitCode_enum {
    pub const NVML_VGPU_COMPATIBILITY_LIMIT_OTHER: nvmlVgpuPgpuCompatibilityLimitCode_enum =
        nvmlVgpuPgpuCompatibilityLimitCode_enum(2147483648);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct nvmlVgpuPgpuCompatibilityLimitCode_enum(pub ::std::os::raw::c_uint);
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuCompatibility_st {
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetMetadata(
    vgpuInstance: nvmlVgpuInstance_t,
    vgpuMetadata: *mut nvmlVgpuMetadata_t,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuMetadata(
    device: nvmlDevice_t,
    pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetVgpuCompatibility(
    vgpuMetadata: *mut nvmlVgpuMetadata_t,
    pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
    compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetPgpuMetadataString(
    device: nvmlDevice_t,
    pgpuMetadata: *mut ::std::os::raw::c_char,
    bufferSize: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetVgpuVersion(
    supported: *mut nvmlVgpuVersion_t,
    current: *mut nvmlVgpuVersion_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlSetVgpuVersion(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuUtilization(
    device: nvmlDevice_t,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    sampleValType: *mut nvmlValueType_t,
    vgpuInstanceSamplesCount: *mut ::std::os::raw::c_uint,
    utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetVgpuProcessUtilization(
    device: nvmlDevice_t,
    lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    vgpuProcessSamplesCount: *mut ::std::os::raw::c_uint,
    utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetAccountingMode(
    vgpuInstance: nvmlVgpuInstance_t,
    mode: *mut nvmlEnableState_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetAccountingPids(
    vgpuInstance: nvmlVgpuInstance_t,
    count: *mut ::std::os::raw::c_uint,
    pids: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceGetAccountingStats(
    vgpuInstance: nvmlVgpuInstance_t,
    pid: ::std::os::raw::c_uint,
    stats: *mut nvmlAccountingStats_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlVgpuInstanceClearAccountingPids(
    vgpuInstance: nvmlVgpuInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBlacklistDeviceInfo_st {
    pub pciInfo: nvmlPciInfo_t,
    pub uuid: [::std::os::raw::c_char; 80usize],
}
pub type nvmlBlacklistDeviceInfo_t = nvmlBlacklistDeviceInfo_st;

#[no_mangle]
pub extern "C" fn nvmlGetBlacklistDeviceCount(
    deviceCount: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGetBlacklistDeviceInfoByIndex(
    index: ::std::os::raw::c_uint,
    info: *mut nvmlBlacklistDeviceInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstancePlacement_st {
    pub start: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
pub type nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_st {
    pub id: ::std::os::raw::c_uint,
    pub isP2pSupported: ::std::os::raw::c_uint,
    pub sliceCount: ::std::os::raw::c_uint,
    pub instanceCount: ::std::os::raw::c_uint,
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub copyEngineCount: ::std::os::raw::c_uint,
    pub decoderCount: ::std::os::raw::c_uint,
    pub encoderCount: ::std::os::raw::c_uint,
    pub jpegCount: ::std::os::raw::c_uint,
    pub ofaCount: ::std::os::raw::c_uint,
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
pub type nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub id: ::std::os::raw::c_uint,
    pub profileId: ::std::os::raw::c_uint,
    pub placement: nvmlGpuInstancePlacement_t,
}
pub type nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGpuInstance_st {
    _unused: [u8; 0],
}
pub type nvmlGpuInstance_t = *mut nvmlGpuInstance_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_st {
    pub id: ::std::os::raw::c_uint,
    pub sliceCount: ::std::os::raw::c_uint,
    pub instanceCount: ::std::os::raw::c_uint,
    pub multiprocessorCount: ::std::os::raw::c_uint,
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    pub sharedJpegCount: ::std::os::raw::c_uint,
    pub sharedOfaCount: ::std::os::raw::c_uint,
}
pub type nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub gpuInstance: nvmlGpuInstance_t,
    pub id: ::std::os::raw::c_uint,
    pub profileId: ::std::os::raw::c_uint,
}
pub type nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlComputeInstance_st {
    _unused: [u8; 0],
}
pub type nvmlComputeInstance_t = *mut nvmlComputeInstance_st;

#[no_mangle]
pub extern "C" fn nvmlDeviceSetMigMode(
    device: nvmlDevice_t,
    mode: ::std::os::raw::c_uint,
    activationStatus: *mut nvmlReturn_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMigMode(
    device: nvmlDevice_t,
    currentMode: *mut ::std::os::raw::c_uint,
    pendingMode: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceProfileInfo(
    device: nvmlDevice_t,
    profile: ::std::os::raw::c_uint,
    info: *mut nvmlGpuInstanceProfileInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstancePossiblePlacements(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    placements: *mut nvmlGpuInstancePlacement_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceRemainingCapacity(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceCreateGpuInstance(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    gpuInstance: *mut nvmlGpuInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceDestroy(gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstances(
    device: nvmlDevice_t,
    profileId: ::std::os::raw::c_uint,
    gpuInstances: *mut nvmlGpuInstance_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceById(
    device: nvmlDevice_t,
    id: ::std::os::raw::c_uint,
    gpuInstance: *mut nvmlGpuInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetInfo(
    gpuInstance: nvmlGpuInstance_t,
    info: *mut nvmlGpuInstanceInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceProfileInfo(
    gpuInstance: nvmlGpuInstance_t,
    profile: ::std::os::raw::c_uint,
    engProfile: ::std::os::raw::c_uint,
    info: *mut nvmlComputeInstanceProfileInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceRemainingCapacity(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceCreateComputeInstance(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    computeInstance: *mut nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlComputeInstanceDestroy(
    computeInstance: nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstances(
    gpuInstance: nvmlGpuInstance_t,
    profileId: ::std::os::raw::c_uint,
    computeInstances: *mut nvmlComputeInstance_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlGpuInstanceGetComputeInstanceById(
    gpuInstance: nvmlGpuInstance_t,
    id: ::std::os::raw::c_uint,
    computeInstance: *mut nvmlComputeInstance_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlComputeInstanceGetInfo(
    computeInstance: nvmlComputeInstance_t,
    info: *mut nvmlComputeInstanceInfo_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceIsMigDeviceHandle(
    device: nvmlDevice_t,
    isMigDevice: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetGpuInstanceId(
    device: nvmlDevice_t,
    id: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetComputeInstanceId(
    device: nvmlDevice_t,
    id: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMaxMigDeviceCount(
    device: nvmlDevice_t,
    count: *mut ::std::os::raw::c_uint,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetMigDeviceHandleByIndex(
    device: nvmlDevice_t,
    index: ::std::os::raw::c_uint,
    migDevice: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}

#[no_mangle]
pub extern "C" fn nvmlDeviceGetDeviceHandleFromMigDeviceHandle(
    migDevice: nvmlDevice_t,
    device: *mut nvmlDevice_t,
) -> nvmlReturn_t {
    crate::r#impl::unimplemented()
}
